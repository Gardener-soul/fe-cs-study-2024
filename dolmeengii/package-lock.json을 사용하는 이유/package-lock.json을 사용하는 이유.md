# package-lock.json을 사용하는 이유

## 개요

Node.js 기반의 프로젝트를 시작할 때, npm install을 통해 모듈을 설치하게 되면 `package.json` 파일과 `package-lock.json` 파일이 생긴다.

package.json은 Node.js 프로젝트에서 사용되는 파일으로, 프로젝트에 관한 기본 정보(이름, 버전, 설명, 작성자, 라이센스 등)와 서드파티 패키지인 의존성 목록을 포함한 파일이다.

> 💡 **서드파티 패키지란?** <br>
> 서드파티란 사전적으로는 제3자를 의미한다. 한마디로, 프로그래밍을 도와주는 라이브러리를 만드는 외부 생산자를 뜻한다. 따라서 서드파티 패키지란 프로젝트와 관련 없는 제3자에 의해 만들어진 패키지를 의미한다. <br>
> 주로 플러그인이나 라이브러리, 프레임워크 등을 의미한다.

package.json은 의존성을 관리한다고 했는데 그럼 package-lock.json은 도대체 뭘까? 두 파일의 차이점에 대해 알아보자.

## package.json

### package.json이란?

![image](https://github.com/dolmeengii/fe-cs-study/blob/9f9c7c5d64d8db519afb7f089a11fad1edfde50b/dolmeengii/package-lock.json%EC%9D%84%20%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%20%EC%9D%B4%EC%9C%A0/images/%08creating-package.png)
npm 공식 문서에 따르면

> 다른 사람들이 쉽게 관리하고 설치할 수 있도록 패키지에 파일을 추가할 수 있습니다. package.json. 레지스트리에 게시된 패키지에는 package.json파일이 포함되어야 합니다.
>
> - 프로젝트가 의존하는 패키지를 나열합니다.
> - `semantic versioning rules` 를 사용하여 프로젝트에서 사용할 수 있는 패키지 버전을 지정합니다.
> - 빌드를 재현 가능하게 만들어 다른 개발자와 공유하기가 더 쉬워집니다. <br>

> 💡 npm 웹사이트에서 패키지를 더 쉽게 찾을 수 있도록, `package.json` 파일에 사용자 정의 description을 포함하는 것이 좋습니다.

앞서 설명한대로 package.json은 해당 프로젝트에 관한 기본적인 정보와 의존성을 명시한 파일임을 알 수 있다.

### package.json 예시

```json
{
  "name": "my_package",
  "description": "make your package easier to find on the npm website",
  "version": "1.0.0",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/monatheoctocat/my_package.git"
  },
  "keywords": [],
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/monatheoctocat/my_package/issues",
    "email": "project@hostname.com"
  }
}
```

위의 예시는 npm 공식 문서에서 가져온 것이다. 이를 바탕으로 package.json 파일에는 어떤 내용이 들어가는지 알아보자.

#### `name`

- 프로젝트의 이름으로 핵심 Node 모듈과 동일한 이름을 사용할 수 없다.
- 필수로 기재해야 하며 다른 패키지와 구별될 수 있도록 고유한 식별자로 작성한다.

#### `version`

- 필수로 기재해야 하며 패키지에 대한 변경 사항은 버전에 대한 변경사항과 함께 제공되어야 한다.

> 💡 패키지를 게시하지 않는다면 name과 version 필드는 선택 사항이다. 하지만 패키지를 게시할 계획이 있다면 필수로 작성해야한다.

#### `description`

- 패키지에 대한 정보를 기재한다.
- 문자열로 입력해야하며, "" 와 같이 빈 문자열로 두어도 된다.

#### `scripts`

- 스크립트 속성은 실행되는 스크립트 명령을 포함하는 사전으로, 위에서는 기본적으로 빈 test 스크립트를 생성한다.
- 키는 수명 주기 이벤트이고 값은 해당 지점에서 실행할 명령이다.

#### `keywords`

- 문자열 배열이다.
- 패키지를 게시했을 때 다른 사람들이 해당 패키지를 쉽게 발견할 수 있게 하기 위해 키워드를 설정한다.

#### `license`

- 패키지를 어떻게 사용할 수 있는지, 패키지에 어떤 제한이 있는지 알 수 있도록 명시해야한다.
- 사용하는 라이선스에 대한 최신 식별자를 추가한다.

#### `bugs`

- 프로젝트 이슈 트래거의 URL 또는 이슈를 보고해야 하는 이메일 주소를 입력한다.
- 값은 하나 혹은 두개를 지정할 수 있다.
- URL만 제공하려는 경우 "bug" 객체 대신 간단한 문자열로 지정할 수 있다.

<br>

### package.json의 한계

package.json은 semantic versioning rules를 따른다고 했는데 이것은 무엇일까? <br>
package.json을 게시하려고 하면 version은 필수로 기재해야한다. 이 때 버전을 지정하는 방식을 semantic versioning rules 라고 한다. <br>
이 방식은 버전 정보 앞에 기호를 부여하여 업데이트 범위를 지정할 수 있다.

| 표기법      | 설명                                                                                                                              |
| ----------- | --------------------------------------------------------------------------------------------------------------------------------- |
| `version`   | 명시된 version과 일치하는 버전                                                                                                    |
| `>version`  | 명시된 version보다 높은 버전                                                                                                      |
| `>=version` | 명시된 version과 같거나 높은 버전                                                                                                 |
| `<version`  | 명시된 version보다 낮은 버전                                                                                                      |
| `<=version` | 명시된 version과 같거나 낮은 버전                                                                                                 |
| `~version`  | 명시된 version의 패치 버전 범위 내에서 업데이트 <br> ex) ~0.0.1: 0.0.1 ≤ version < 0.1.0 <br> ex) ~0.1.1: 0.1.1 ≤ version < 0.2.0 |
| `^version`  | 명시된 version과 호환되는 버전. 마이너 버전 범위 내에서 업데이트 <br> ex) ^1.0.2: 1.0.2 ≤ version < 2.0                           |

그래서 만약 패키지A에 대해 `^1.1.5` 버전을 설정해두면, 내 로컬에는 `1.1.6`이 설치될 수도 있고 `1.2`가 설치 될 수도 있다. <br>
혼자서 개발하는 경우에는 문제가 없을 수도 있지만, 여러명이서 협업을 해야 하는 경우에 배포될 때 설치되는 버전을 명확하게 할 수 없다는 문제가 발생한다.

## package-lock.json

### package-lock.json이란?

![image](https://github.com/dolmeengii/fe-cs-study/blob/9f9c7c5d64d8db519afb7f089a11fad1edfde50b/dolmeengii/package-lock.json%EC%9D%84%20%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%20%EC%9D%B4%EC%9C%A0/images/description-package-lock.png)
npm 공식 문서에 따르면

> `package-lock.json`은 **`node_modules 트리` 또는 `package.json` 을 수정하는 모든 작업에 대해 자동으로 생성**됩니다. 이는 생성된 정확한 트리를 설명하므로 후속 설치에서 중간 종속성 업데이트와 관계없이 동일한 트리를 생성할 수 있습니다.

> 이 파일은 소스 저장소에 커밋되도록 만들어졌으며 다양한 용도로 사용됩니다.
>
> - 팀원, 배포 및 지속적인 통합이 정확히 동일한 종속성을 설치하도록 보장할 수 있는 종속성 트리의 단일 표현을 설명합니다.
> - 사용자가 디렉토리 자체를 커밋하지 않고도 node_module의 이전 상태로 "시간 여행"할 수 있는 기능을 제공합니다.
> - 읽기 쉬운 소스 제어 diff를 통해 트리 변경 사항의 가시성을 높입니다.
> - 이전에 설치된 패키지에 대해 npm이 반복되는 메타데이터 확인을 건너뛸 수 있도록 하여 설치 프로세스를 최적화합니다.
> - npm v7부터 잠금 파일에 패키지 트리의 전체적인 그림을 얻을 수 있는 충분한 정보가 포함되어 package.json파일을 읽을 필요성이 줄어들고 성능이 크게 향상되었습니다.

> npm이 `package-lock.json`을 생성하거나 업데이트 할 때 `package.json`로부터 줄바꿈과 들여쓰기를 추론하여 두 파일의 서식이 일치하도록 합니다.

한마디로 요약하자면 package-lock.json은 파일에 생성될 때 의존성 트리를 작성하여 잠금하므로, 정확한 정보를 저장하고 있어 파일이 작성된 시점의 의존성 트리를 다시 불러올 수 있도록 보장한다는 것이다.

```Markdown
### GPT와의 대화 내용 중
package-lock.json은 의존성 트리를 잠금하여, 프로젝트의 모든 개발자가 동일한 의존성 구조를 사용하도록 합니다.
예를 들어, 한 개발자가 npm install을 실행할 때, package-lock.json에 명시된 버전이 우선적으로 사용되므로, 의존성의 버전이 변경되지 않습니다.
이는 팀 내에서의 일관성을 유지하는 데 매우 중요합니다.
```

#### 🧚🏻‍♀️ 쉽게 이해해보기

1. 프로젝트를 처음 만들 때 버전 1.2.0 버전을 설치했다.
2. 이후 npm install 을 하여 1.3.0 버전으로 설치한다. 작업이 끝난 후 package.json과 함께 package-lock.json도 함께 커밋한다.
3. 이 때 package-lock.json 파일을 커밋하지 않고 다른 사람이 Pull 하여 npm install을 실행하게 되면 나의 의존성 트리와 다른 사람의 의존성 트리가 다르게 설치되어 프로그램 실행 시 오류가 발생하게 된다.
   > - 원격 저장소에 저장된 의존성 트리 : 1.2.0 <br>
   > - 다른 개발자 package.json : 1.3.0 <br>
   >   npm install 시, 다른 개발자는 package.json에 명시된 버전을 따라 1.3.0으로 업데이트 되려고 할 것이다. 하지만 원격 저장소에 저장된 의존성 트리에는 버전이 1.2.0으로 저장되어 있기 때문에 pull 을 받은 후 새로 npm install 을 하려고 하면 버전 불일치로 오류가 발생할 수 있다.

따라서 패키지 작업을 끝낸 후 커밋을 할 때에는 package.json과 package-lock.json 모두 커밋을 해줘야 한다.

---

---

#### 🔖 참고 사이트

- [블로그 - 써드파티(3rd party)란?](https://gyoogle.dev/blog/computer-science/software-engineering/3rd%20party.html)
- [npm 공식 문서 - Creating a package.json file](https://docs.npmjs.com/creating-a-package-json-file)
- [npm 공식 문서 - package.json](https://docs.npmjs.com/cli/v10/configuring-npm/package-json)
- [npm 공식 문서 - package-lock.json](https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json)
- [티스토리 - 알아두면 쓸데있는 package.json과 package-lock.json의 차이](https://dev-ellachoi.tistory.com/65#:~:text=package%2Dlock.json%20%ED%8C%8C%EC%9D%BC%20%EC%95%88%EC%97%90%EB%8A%94,%ED%95%98%EB%8A%94%20%EB%8D%B0%EC%97%90%20%EC%82%AC%EC%9A%A9%EB%90%9C%EB%8B%A4.)
- [티스토리 - [npm]package-lock.json이 필요한 이유](https://jihyundev.tistory.com/21)
- [velog - package.json/package-lock.json 알고 사용하자!](https://velog.io/@dongeun-i/package.json-package-lock.json-%EC%95%8C%EA%B3%A0-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90)
- [velog - Semantic Versioning-배포 관리(규칙)](https://velog.io/@goodjam92/Semantic-Versioning-%EB%B0%B0%ED%8F%AC-%EB%B2%84%EC%A0%84-%EA%B7%9C%EC%B9%99)
