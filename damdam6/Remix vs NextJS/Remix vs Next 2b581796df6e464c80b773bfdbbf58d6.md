# Remix vs NextJS

![image.png](image.png)

### Remix

- 2021년 릴리즈
- 웹 내장 기능에 중점을 둠. (쿠키, url 매개변수, HTTP의 기본 캐싱 기능)
- 혁신적인 데이터 fetching도입 → React의 전통적인 상태관리 방식의 필요성이 줄어듦
    - 확인 필요
- 파일시스템을 기반으로 한 간단한 라우팅 모델 제공
    
    → NextJS도 있으나 Remix에 유연한 옵션이 추가됨.
    

### Next.js

- 2016 출시
- SSR과 SSG가 Next.js에서는 우선임.
- 파일 시스템 기반의 자동 라우팅 메커니즘
    - 동적 라우팅이 비교적 쉬움.
- 이미지 최적화, 다국어 지원, 코드 스플리팅 및 클라이언트 사이드 네비게이션과 같은 고급 기능 내장

---

## 성능 비교

### 성능 비교 지표

1. 정적 및 동적 콘텐츠의 로드 속도
2. 모바일 기기와 느린 연결에서의 로드 속도
3. 최종 사용자 경험
4. 오류 처리
5. 데이터 변형(data mutations)
6. 빌드 시간
7. 개발자 경험

### 1. 정적 및 동적 콘텐츠의 로드 속도

- Next.js의 정적 및 동적 콘텐츠 로드 속도 처리
    - SSG 및 SSR를 활용하여 정적 및 동적 콘텐츠 모두에 대해 효율적인 로드 시간 제공
    - ISR을 통해 정적 페이지가 생성된 후에도 업데이트 가능
        - ISR이란?
            - 초기 정적 페이지 생성 후 백그라운드에서 페이지 재생성을 통해 최신 데이터가 반영된 페이지를 빠르게 받을 수 있음. (사용자는 대기하지 않아도 됨)
    - BUT.. SSG는 동적 페이지와의 확장성이 떨어짐
        
        ⇒ 결국 클라이언트 측에서 데이터를 가져오는 경우 많음.
        
        ⇒ 시간이 더 요구됨.
        

- Remix의 정적 및 동적 콘텐츠 로드 속도 처리
    - SSG 방식 지원 X → but HTTP의 캐싱 기능 활용해 콘텐츠의 빠른 로드 속도 제공
    - 동적 컨텐츠 - SSR와 React Hydration을 통해 빠른 로드 및 탐색 시간 달성
    
    - Remix에서 진행한 테스트에 따르면
        - Remix는 정적 콘텐츠 제공에서 Next.js와 동등하거나 더 빠릅니다.
        - Remix는 동적 콘텐츠 제공에서 Next.js보다 빠릅니다.

- 정적 및 동적 콘텐츠 로드 속도 처리에 따른 프레임워크 선택
    - Remix
        - 동적 콘텐츠를 위한 SSR을 우선하는 시스템
            - 더 빠른 초기 로드 시간과 향상된 SEO 필요할 때
        - 대부분의 콘텐츠를 서버에서 생성하고 클라이언트에서 hydration하는 통합된 방식을 선호할 때
    - Next.js
        - 콘텐츠에 따라 SSG와 SSR 중 하나를 선택할 수 있는 유연성이 요구될 때
        - 클라이언트 측 데이터 페칭 및 동적 업데이트를 활용하면서 성능을 높이고 싶을때
            - Remix는 클라이언트 사이드의 api호출을 권장하지 않음.
    

### 2. 모바일 기기와 느린 연결에서의 로드 속도 비교

- Next.js : 성능 최적화가 잘 이루어짐
    - 자동 이미지 최적화
    - 코드 스플리팅을 통한 파일 크기 감소
    - pre-fetching 네비게이션으로 미리 데이터 가져오기
    - SSG 및 SSR 지원을 통한 유연한 렌더링 방식
- Remix : 성능이 뛰어난 편
    - 기본적으로 앱 주요 기능이 js 다운 전 동작하도록 권장하고 있음.
    - js 다운 이후 Optimistic UI를 구축할 수 있는 도구를 제공
        - Optimistic UI : 사용자가 어떤 작업을 수행했을 때, 그 작업의 결과가 서버로부터 실제로 완료되기 전에, UI가 마치 성공한 것처럼 즉시 업데이트 되는 방식

### 3. 사용자 경험(UX) 비교

- Next.js의 사용자 경험 처리
    - ISR, 이미지 최적화로 원활한 사용자 경험 제공
    - Client-Side-Navigation을 통해 페이지 빠른 로드 가능

        참고 : https://nextjs.org/learn-pages-router/basics/navigate-between-pages/client-side
        
    - 페이지 수준에서 코드 스플리팅이 자동으로 발생
- Remix의 사용자 경험 처리
    - Optimistic UI로 최적화
    - 초기 페이지 로드와 매끄러운 전환이 중요한 디자인 요소일때 유리

### 4. 에러 처리(Error handling) 비교

- 기본적인 React의 에러 처리
    - 에러 경계(error boundaries)를 통한 자연스러운 처리
        - `에러 경계는 **컴포넌트 트리가 깨지는 대신 자식 컴포넌트 트리에서 에러를 잡아내고, 이러한 에러의 로그를 남기고, 폴백 UI를 보여주는 React 컴포넌트**입니다.`  - React Docs
        - Next.js와 Remix 모두 해당 처리 제공
- Next.js의 에러 처리
    - 기본 에러 페이지 및 사용자 정의 에러 페이지 제공
    - 사용자 정의 에러 페이지
        - 404(페이지 없음)이나 500(서버 오류)와 같은 에러 처리 가능한 사용자 정의 에러 페이지를 만들 수 있도록 지원함.
        - `pages/404.js`  `pages/500/js` 경로를 통해 생성 가능
    - 서버 사이드 렌더링 및 정적 페이지 생성에서의 에러 처리 지원
- Remix의 에러 처리
    - `ErrorBoundary` 을 통해서 설정
    - `loaderError` `jsonError` 등 라이프 사이클 훅을 통해 데이터 로딩 중 발생하는 에러 컨트롤

- 에러 처리에 기반한 프레임워크 비교
    - 간단한 에러 헨들링 선호 → Remix
    - 커스텀화 된 에러 처리 세팅이 필요할때 →  Next.js

### 5. 데이터 변경 (Data mutations)

- data mutation
    - 사용자가 사이트나 앱과 상호작용 할 때, 정보를 입력, 변경, 데이터를 업데이트 하는 이벤트를 트리거 하는 것을 의미
    
- Next.js의 data mutation
    - client-side : React 도구를 사용하여 관리
    - server-side : 서버에서 데이터를 변경 처리할 수 있는 기능 제공
        - DB 업데이트와 같은 작업에 유용
            
            ```java
            // pages/api/updateData.js
            export default function handler(req, res) {
              if (req.method === 'POST') {
                // 요청 데이터로 데이터베이스 업데이트하기
                const { id, newData } = req.body;
            
                // 여기에 데이터베이스 로직을 추가 (예: MySQL, MongoDB 등)
                
                res.status(200).json({ message: 'Data updated successfully' });
              } else {
                res.status(405).end(); // 허용되지 않은 메서드 처리
              }
            }
            ```
            
- remix의 data mutation
    - HTML 폼을 사용하거나 Remix의 `Form` 컴포넌트를 통해 자바스크립트로 에뮬레이션 할 수 있음.
    - 단순하고 알기 쉬운 방식으로 구현 가능.

### 6. 빌드 타임 비교

- Build time 의 필요성
    - 빠르게 반복적으로 변경 가능함.
    - 대형 프로젝트의 경우 빌드 타임이 중요함.
    - 두 프레임워크는 유사한 성능을 보이나 부정적인 경우가 일부 정해져 있음.
    
- Next.js의 빌드 시간 - 긍정
    - Next.js는 빠른 빌드 시간을 지향함.
    - 효율적인 코드 컴파일이 발생함. (변경된 부분만 컴파일함)
    - 자동적인 코드 스플리팅을 통해 최적화를 진행함. 또한 이미지 최적화 등을 자동으로 수행.
- Next.js의 빌드 시간 - 주의점
    - 프로젝트 크기가 클 경우 빌드 시간이 길어짐.
    - 동적 데이터를 빌드타임에 불러올 경우 느려질 수 있음.
    - 서버리스 함수를 지원하므로 이를 복잡하게 사용할 경우 빌드가 느려질 수 있음.

- Remix의 빌드 시간 - 긍정
    - 빌드 시간이 상당히 빠르며 대규모 코드베이스나 복잡한 프로젝트에서는 Next.js보다 빠른 빌드가 가능함.
    - 효율적으로 컴파일 됨. (Next.js와 동일)
    - 자동 최적화.
- Remix의 빌드 시간 - 주의점
    - 복잡한 라우팅 요구사항이 있을 경우 빌드 시간이 늘어날 수 있음.
    - 커스텀 데이터 로딩을 통해 미리 데이터를 불러오는 기능(페이지에 적용하기 위해)이 있는데 해당 코드가 복잡해질 경우 빌드가 느려짐.

---

https://velog.io/@supremgy/ChatGPT가-Next.js에서-Remix로-갈아탔데

https://zerotomastery.io/blog/remix-vs-next/

https://reactjs-kr.firebaseapp.com/docs/error-boundaries.html
