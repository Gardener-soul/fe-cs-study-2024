# CallBack Function : 콜백 함수
 
정의 : 다른 코드의 인자로 넘겨주는 함수. 콜백 함수를 넘겨받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행한다.

## 1. 제어권
콜백 함수는 다른 코드 (함수 또는 메서드) 에게 인자로 넘겨줌으로써, 그 제어권도 함께 위임한 함수입니다.

콜백 함수를 위임받은 코드는 자체적인 내부 로직에 의해 이 콜백 함수를 적절한 시점에 실행하게 됩니다. 예제로 알아봅시다!

### 1) 호출 시점
```js
var count = 0;
var cbFunc = function() {
    console.log(count);
    if(++count>4) clearInterval(timer);
};

var timer = setInterval(cbFunc,300);
```

| Code                      | 호출 주체        | 제어권         |
|---------------------------|--------------|-------------|
| cbFunc();                 | 사용자          | 사용자         |
| setInterval(cbFunc, 300); | setInterval  | setInterval |

위 코드를 실행하면 콘솔창에는 0.3초에 한 번씩 숫자가 0부터 1씩 증가하며 출력되다가 4가 출력된 이후 종료된다. 
**setInterval** 이라고 하는 '다른 코드' 에 첫 번째 인자로서 cbFunc 함수를 넘겨주자 제어권을 넘겨받은 setInterval이 스스로의 판단에 따라 적절한 시점에 (0.3초 마다) 이 익명 함수를 실행했습니다.

이처럼 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수 호출 시점에 대한 제어권을 가집니다.

사용자가 제어권을 가질 때: 사용자는 함수가 실행되는 시점을 완전히 통제합니다. 즉, 사용자가 함수 호출을 언제든지 결정할 수 있습니다.

setInterval이 제어권을 가질 때: setInterval은 사용자가 함수의 실행 시점을 직접 결정하지 않고, 설정된 간격에 따라 자동으로 함수를 호출합니다.

### 2) 인자

```js
var newArr = [10,20,30].map(function(currentValue, index){
    console.log(currentValue, index);
    return currentValue+5;
});

console.log(newArr)
```
이 부분에서 map 함수가 어떤 인자를 받아서 콜백 함수로 기능하는지 알아볼 필요가 있다.

```js
Array.prototype.map(callback[, thisArg])
callback: function(currentValue, index, array)
```
map 매소드는 첫 번째 인자로 callback 함수를 받고, 생략 가능한 두 번째 인자로 콜백 함수 냅부에서 this로 인식할 대상을 특정할 수 있다. thisArg를 생략할 경우에는 일반적인 함수와 마찬가지로 전역객체가 바인딩됩니다. map 매서드는 메서드의 대상이 되는 배열의 모든 요소들을 처음부터 끝까지 하나씩 꺼내어 콜백 함수를 반복 호출하고, 콜백 함수의 실행결과들을 모아 새로운 배열을 만듭니다.

위 예시의 경우 콜백 함수의 첫 번째 인자에는 배열의 요소 중 현재값이, 두 번째 인자에는 현재값의 인덱스가, 세 번째 인자에는 map 메서드의 대상이 되는 배열 자체가 담깁니다.

이렇듯 map 메서드에 정의된 규칙에 따라 함수를 작성해야 합니다. map 메서드에 정의된 규칙에는 콜백 함수의 인자로 넘어올 값들 및 그 순서도 포함되어 있습니다. 이처럼 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대한 제어권을 가집니다.

### 3) this
뜬금없지만 콜백 함수는 함수입니다. 당연한 소리이지만, 콜백 함수로 어떤 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 함수로서 호출됩니다.

```js
var obj = {
    vals: [1,2,3],
    logValues: function(v,i) {
        console.log(this, v, i);
    }
};

obj.logValues(1, 2); // 출력 값 { vals: [1,2,3], logValues: f } 1 2

[4,5,6].forEach(obj.logValues); // Window { ... } 4 0 ...(이하 생략) 
```
obj 객체의 logValues는 메서드로 정의됐습니다. (메서드의 이름 앞에 '.' 이 있으므로 메서드로서 호출한 것) -> 따라서 this는 obj 를 가리키고, 인자로 넘어온 1과 2가 출력됩니다.

한편 다음 줄에서는 
1. 이 메서드롤 forEach 함수의 콜백 함수로 전달했습니다. obj를 this로 하는 메서드를 그대로 전달한 것이 아니라 obj.logValues 가 가리키는 함수만 전달한 것.
2. 이 함수는 메서드로서 호출할 때가 아닌 한 obj와의 직접적인 연관이 없어집니다.
3. forEach에 의해 콜백이 함수로서 호출됩니다.
4. 별도로 this를 지정하는 인자를 지정하지 않았으므로 함수 내부에서의 this는 전역객체 (Window) 를 바라보게 됩니다.

어렵죠 다 잊어버려도 알아야 할 것은 **"어떤 함수의 인자에 객체의 메서드를 전달하더라도, 이는 메서드가 아닌 함수"** 라는 것을, 이 차이를 이해하는 것이 중요합니다.

## 2. 콜백 함수 내부의 this에 다른 값 바인딩하기
그렇다면 위와 같이 객체의 메서드를 콜백 함수로 전달하면 해당 객체를 this로 바라볼 수 없게 된다는 점을 해결하기 위해서 어떻게 해야할까? 

바로 bind 메서드를 이용하는 방법이다.

```js
var obj1 = {
    name: 'obj1',
    func: function() {
        console.log(this.name);
    }
};

setTimeout(obj1.func.bind(obj1), 1000);

var obj2 = {name: 'obj2'};
setTimeout(obj1.func.bind(obj2), 1500);
```

bind를 통해 this를 명시적으로 지정하게 되어, 콜백 함수거 안제, 어떻게 호출되는지 'this'는 항상 우리가 지정한 객체를 가리키게 된다!

## 3. 콜백 지옥과 비동기 제어
콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상이 일어나는 것이 JS의 주요한 문제이다. JS는 비동기의 특성을 띄고 있기 때문이다! 이러한 비동기 함수의 반복되는 콜백으로 인한 문제를 해결하기 위한 방법을 알아본다!

### 1) 기명함수로 변환하기
 익명의 콜백함수를 모두 기명함수로 전환하는 것.
 
### 2) Promise
 new 연산자와 함께 호출한 Promise의 인자로 넘겨주는 콜백함수는 호출할 때 바로 실행되지만, 내부의 resolve 또는 reject 함수를 호출하는 구문이 있을 경우 둘 중 하나가 실행되기 전까지는 다음 (then) 또는 오류 구문 (catch) 구문으로 넘어가지 않는다. 따라서 Promise 를 사용하여 resolve 또는 reject를 호출하는 방법으로 비동기 작업의 동기적 표현이 가능해진다.
 
### 3) Generator

```js
var here = function* () {
    
};
```

1. here 함수를 잘 보면 function 옆에 *이 붙은 함수를 확인할 수 있다. 이것이 바로 Generator 함수
2. Generator 함수를 실행하면 Iterator가 반환된다.
3. Iterator는 next라는 메서드를 가지고 있다.
4. 이 next 메서드를 호출하면 Generator 함수 내부에서 가장 먼저 등장하는 yield에서 함수의 실행을 멈춘다.
5. 이후 다시 next 메서드를 호출하면 앞서 멈췄던 부분부터 시작해서 그 다음 등장하는 yield 함수의 실행을 멈춘다.
6. 결론! 비동기 작업이 완료되는 시점마다 next 메서드를 호출해준다면 Generator 함수 내부의 소스들이 위에서부터 아래로 순차적으로 진행된다.

### 4) 진리의 async/await

비동기 작업을 수행하고자 하는 함수 앞에 async를 표기하고 함수 내부에서 실질적인 비동기 작업이 필요한 위치마다 await 을 표기하는 것만으로 뒤의 내용을 Promise로 자동 전환하고, 해당 내용이 resolve 된 이후에야 다음으로 진행한다.

## 4. 정리

1. 콜백 함수는 다른 코드에 인자로 넘겨줌으로 그 제어권도 함께 위임한 함수이다.
2. 제어권을 넘겨받은 코드는 다음과 같은 제어권을 가진다.
   1) 콜백 함수를 호출하는 시점을 스스로 판단해서 실행
   2) 콜백함수를 호출할 때 인자로 넘겨줄 값들 및 그 순서가 정해져 있다.
   3) 콜백 함수의 this가 무엇을 바라보도록 할지 정해져 있는 경우도 있다. / 정하지 않은 경우에는 전역객체를 바라보고, 임의로 this를 변경하고 싶을 경우 bind 메서드를 활용한다.
3. 어떤 함수에 인자로 메서드를 전달하더라도, 이는 결국 함수로서 실행된다.
4. 비동기 제어를 위해 주로 Promise, Generator, async/await 등을 사용한다